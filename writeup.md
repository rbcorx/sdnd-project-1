# **Finding Lane Lines on the Road** 


**Finding Lane Lines on the Road**

The goals / steps of this project are the following:
* Make a pipeline that finds lane lines on the road
* Reflect on your work in a written report

---

### Reflection

### 1. Describe your pipeline. As part of the description, explain how you modified the draw_lines() function.

I initially used all 5 steps in my pipeline encompassing in order: graying, gaussian blur, canny edge, area of interest masking and houghlines selection, but later after experimenting for a bit, I realized that skipping the grayscale step gave best better results for the challenge video without affecting the other videos.

### Drawing single lane lines:

**Idea and Inspiration**
The goal is to identify the lines which are part of the same lane line and merge them to get a single line. I merged them using weighted mean (by length) of slope and y-intercept as I want the longer line segments to dominate the result as they are more likely to represent lane lines.

The trickiest part is to choose/discard lines to be merged for the same lane line. Eliminating the noise is crucial.

I noticed that as lane lines go from left to right, their slope (considering the image x, y with origin at top left), their slopes first decrease, going from zero (for a horizontal) to negative to -infinity in the center and then +infinity to positive to zero (for a horizontal) towards the right, similarly the y-intercept starts from some constant C for a horizontal line on the left, increases to infinity in the center and then from -infinity, increase back to C while going right. 

In case of lines which curve towards the top, the line may be approximated to smaller lines located inside horizontal brackets which divide the screen and they iterate over the initial slope and intercepts in a discernable pattern depending on curving towards right or left.

**Points to note are:** 
- lines constituting different lane lines can be clustered on the basis of dynamic bins of slopes and intercept. 
- for curved lines, we divide the screen in multiple horizontal brackets to cluster separate lanes in each bracket individually and later connect part of the lane up the screen by minimizing distance between the endpoints of the merged lines while maintaining slope and intercept continuity between adjacent lines of the same lane. We simply break a line which doesn't fit in a bracket, as it will be merged as a whole anyways and no information will be lost.
- this algorithm ideally divides the screen into a virtual grid using parameters like slope, y-intercept and endpoint coordinates and piecewise, builds the lane lines, potentially handling any number of lane lines and any curving.

Statistically speaking, we want to choose 'bins', i.e. lanes (may be multiple) dynamically by minimizing standard deviation of slope and intercept within a bin and we want to do this separately for multiple horizontal bins and finally merge the lines on the basis of coordinate proximity while maintaining slope and intercept continuity as we fill in missing parts by extrapolation.


**Theory apart**, I didn't implement this whole algorithm for now, but I would like your thoughts on this approach.
Instead, I added a slew of helper functions of my own to build a line filtering pipeline which can filter lines on the basis of set brackets of slope, intercept, and separation towards the left or right of any line drawn from y==0 to y==height. 

Ideally, these brackets should have been dynamically generated by using proper heuristics and minimizing standard deviation.

I set the value of these brackets manually for the left and right lane line after experimentation and filter out any possible noise.
I'm also not dividing the screen into horizontal brackets and just merging everything into a straight line for now.

##### Merging with Previous frames for smoother result
Then, after merging all filtered lines into the left and right, I create my current frame with their coordinates and for stable and smooth rendering, merge the current frame with the last 8 frames. 

I have created separate functions for each purpose and the parameters can be tuned as such to modufy the filtering pipeline.


### Shortcomings and Improvements

Because the whole algorithm isn't implemented, I have to manually set parameters which will change further up a curved line or while switching lines. Ideally, the algorithm should dynamically find out proper bins of slope, intercepts and positioning while dividing the screen into multiple horizontal bins to handle curves.

Also this approach will fail miserably on sections of the road with faded lane lines, in which case, we either extrapolate previous results while adjusting for any turning in the interim which is a bad solution, or start detecting roads/trails directly.

One problem I have is in the second (yellow) video, after I apply the frame merger with the last 8 frames, the left lane starts drawn towards the extreme right and then rapidly moves towards the left to it's rightful place. I have attributed it to initial noise and tried skipping merging first few frames but the results don't change. I intend to investigate further by drawing the last 8 frames together on the screen in different colors and it might shed light on what's going on. Could you comment on this, though?

